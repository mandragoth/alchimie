import "input.gr"

export func setupCamera() {
    camera3D();
    camera2D();
    //splitScreen();
}

task camera2D() {
    var camera = @OrthographicCamera();

    // 2D camera controls removed for now
    /*var moveSpeed = 0.01f;
    var zRotationSpeed = rad(2f);
    var zoomSpeed = 0.05f;
    var wheelFrames = 5;

    var cPosition = camera:position();
    var zRotation = camera:rotation();
    var zoomLevel = camera:zoom();

    loop yield {
        cPosition.x += getActionAxis("move_left", "move_right") * moveSpeed;
        cPosition.y += getActionAxis("move_down", "move_up") * moveSpeed;
        zRotation += getActionAxis("roll_right", "roll_left") * zRotationSpeed;

        if (isActionActivated("zoom_in")) {
            zoomLevel -= zoomSpeed;
        } else if (isActionActivated("zoom_out")) {
            zoomLevel += zoomSpeed;
        }

        zoomLevel = clamp(zoomLevel, 0.25f, 1.5f);

        camera:position(cPosition);
        camera:rotation(zRotation);
        camera:zoom(zoomLevel);
    }*/
}

task camera3D() {
    var camera = @PerspectiveCamera();
    camera.position = @vec3f(0f, .5f, 2f);

    var moveSpeed = .05f;
    var zoomSpeed = .15f;
    var mouseSensitivity = .5f;
    var controllerSensitivity = 2f;
    var minRotX = rad(5f);

    var cPosition = camera.globalPosition;

    loop yield {
        var xAxis = camera.right;
        var yAxis = camera.up;
        var zAxis = camera.forward;

        cPosition += xAxis * getActionAxis("move_left", "move_right") * moveSpeed +
                     yAxis * getActionAxis("move_down", "move_up") * moveSpeed +
                     zAxis * getActionAxis("move_backward", "move_forward") * zoomSpeed;
        camera:position(cPosition);

        var deltaPos = @vec2i(mouseX, mouseY);
        var rotX = mouseSensitivity * deltaPos.x + controllerSensitivity * getActionAxis("turn_left", "turn_right");
        var rotY = mouseSensitivity * deltaPos.y + controllerSensitivity * getActionAxis("turn_down", "turn_up");

        mouseX, mouseY = 0;

        // Rotate Z around X
        var newZAxis = rotate(zAxis, xAxis, rad(-rotY));

        // New angle between (z, y)
        var angleUp = angleBetween(newZAxis, yAxis);
        var angleDown = angleBetween(newZAxis, -yAxis);

        // Limit rotation around X
        if (angleUp > minRotX && angleDown > minRotX) {
            camera:forward(newZAxis);
        }

        // Rotate Z around Y
        camera:forward(rotate(newZAxis, yAxis, rad(-rotX)));

        // @TODO Get mouse position, create a Ray from it (cached as private variable)
        // @TODO Use ray to query entities in the scene, fetch the one closest to the camera near plane
    }
}

task splitScreen() {
    var width = screenWidth();
    var height = screenHeight();

    var halfWidth = width / 2;
    var halfHeight = height / 2;

    var cam1 = @PerspectiveCamera(width, height, @vec3(0f, 0f, 5f), @vec3(0f, 0f, -1f), @vec3(0f, 1f, 0f));
    cam1:viewport(@vec4i(0, 0, halfWidth, halfHeight));

    var cam2 = @PerspectiveCamera(width, height, @vec3(0f, 0f, -5f), @vec3(0f, 0f, 1f), @vec3(0f, 1f, 0f));
    cam2:viewport(@vec4i(0, halfHeight, halfWidth, halfHeight));

    var cam3 = @PerspectiveCamera(width, height, @vec3(5f, 0f, 0f), @vec3(-1f, 0f, 0f), @vec3(0f, 1f, 0f));
    cam3:viewport(@vec4i(halfWidth, 0, halfWidth, halfHeight));

    var cam4 = @PerspectiveCamera(width, height, @vec3(-5f, 0f, 0f), @vec3(1f, 0f, 0f), @vec3(0f, 1f, 0f));
    cam4:viewport(@vec4i(halfWidth, halfHeight, halfWidth, halfHeight));
}