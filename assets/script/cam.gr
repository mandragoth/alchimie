public func setupCamera() {
    setupControls();
    //camera2D();
    camera3D();
    //splitScreen();
}

func setupControls() {
    addAction("move_up", 0.2);
    addAction("move_down", 0.2);
    addAction("move_left", 0.2);
    addAction("move_right", 0.2);
    addAction("roll_left", 0.2);
    addAction("roll_right", 0.2);
    addAction("zoom_in", 0.2);
    addAction("zoom_out", 0.2);

    addActionEvent("move_up", @InputEvent.controllerAxis(ControllerAxis.leftY, -1f));
    addActionEvent("move_up", @InputEvent.controllerButton(ControllerButton.up, true));
    addActionEvent("move_up", @InputEvent.keyButton(KeyButton.up, true, false));
    addActionEvent("move_up", @InputEvent.keyButton(KeyButton.w, true, false));

    addActionEvent("move_down", @InputEvent.controllerAxis(ControllerAxis.leftY, 1f));
    addActionEvent("move_down", @InputEvent.controllerButton(ControllerButton.down, true));
    addActionEvent("move_down", @InputEvent.keyButton(KeyButton.down, true, false));
    addActionEvent("move_down", @InputEvent.keyButton(KeyButton.s, true, false));

    addActionEvent("move_left", @InputEvent.controllerAxis(ControllerAxis.leftX, -1f));
    addActionEvent("move_left", @InputEvent.controllerButton(ControllerButton.left, true));
    addActionEvent("move_left", @InputEvent.keyButton(KeyButton.left, true, false));
    addActionEvent("move_left", @InputEvent.keyButton(KeyButton.a, true, false));

    addActionEvent("move_right", @InputEvent.controllerAxis(ControllerAxis.leftX, 1f));
    addActionEvent("move_right", @InputEvent.controllerButton(ControllerButton.right, true));
    addActionEvent("move_right", @InputEvent.keyButton(KeyButton.right, true, false));
    addActionEvent("move_right", @InputEvent.keyButton(KeyButton.d, true, false));

    addActionEvent("roll_left", @InputEvent.controllerButton(ControllerButton.leftShoulder, true));
    addActionEvent("roll_left", @InputEvent.keyButton(KeyButton.q, true, false));

    addActionEvent("roll_right", @InputEvent.controllerButton(ControllerButton.rightShoulder, true));
    addActionEvent("roll_right", @InputEvent.keyButton(KeyButton.e, true, false));

    addActionEvent("zoom_in", @InputEvent.keyButton(KeyButton.numPlus, true, false));
    addActionEvent("zoom_out", @InputEvent.keyButton(KeyButton.numMinus, true, false));
}

task camera2D() {
    var camera = @OrthographicCamera();

    var moveSpeed = 0.01f;
    var zRotationSpeed = rad(2f);
    var zoomSpeed = 0.05f;

    var cPosition = camera:position();
    var zRotation = camera:rotation();
    var zoomLevel = camera:zoom();

    loop yield {
        cPosition.x += getActionAxis("move_left", "move_right") * moveSpeed;
        cPosition.y += getActionAxis("move_down", "move_up") * moveSpeed;
        zRotation += getActionAxis("roll_right", "roll_left") * zRotationSpeed;

        if (isActionPressed("zoom_in")) {
            zoomLevel -= zoomSpeed;
        } else if (isActionPressed("zoom_out")) {
            zoomLevel += zoomSpeed;
        }

        zoomLevel = clamp(zoomLevel, 0.25f, 1.5f);

        camera:position(cPosition);
        camera:rotation(zRotation);
        camera:zoom(zoomLevel);
    }
}

task camera3D() {
    var camera = @PerspectiveCamera();
    camera:position(@vec3(0f, 0.5f, 2f));

    var moveSpeed = 0.05f;
    var mouseSensitivity = .25f;

    var cPosition = camera:position();

    // @TODO use axis once native vectors implemented
    /*var xAxis = camera:right();
    var yAxis = camera:up();
    var zAxis = camera:forward();*/

    loop yield {
        cPosition.x += getActionAxis("move_left", "move_right") * moveSpeed;
        cPosition.y += getActionAxis("move_down", "move_up") * moveSpeed;
        cPosition.z += getActionAxis("zoom_in", "zoom_out") * moveSpeed;

        // @TODO Get mouse position, create a Ray from it (cached as private variable)
        // @TODO Use ray to query entities in the scene, fetch the one closest to the camera near plane

        // @TODO mouse lookup
        /*const vec2 deltaPos = getRelativeMousePos(); // @TODO mouse pos here

        const float rotX = sensitivity * deltaPos.y;
        const float rotY = sensitivity * deltaPos.x;

        const vec3 newOrientation = rotate(_camera.forward, -rotX * degToRad, _camera.right);

        const float limitRotX = 5f * degToRad;

        const float angleUp = angle(newOrientation, _camera.up);
        const float angleDown = angle(newOrientation, -_camera.up);

        if (!(angleUp <= limitRotX || angleDown <= limitRotX)) {
            _camera.forward = newOrientation;
        }

        _camera.forward = rotate(_camera.forward, -rotY * degToRad, _camera.up);*/

        camera:position(cPosition);
    }
}

task splitScreen() {
    var width = screenWidth();
    var height = screenHeight();

    var halfWidth = width / 2;
    var halfHeight = height / 2;

    var cam1 = @PerspectiveCamera(width, height, @vec3(0f, 0f, 5f), @vec3(0f, 0f, -1f), @vec3(0f, 1f, 0f));
    cam1:viewport(@vec4i(0, 0, halfWidth, halfHeight));

    var cam2 = @PerspectiveCamera(width, height, @vec3(0f, 0f, -5f), @vec3(0f, 0f, 1f), @vec3(0f, 1f, 0f));
    cam2:viewport(@vec4i(0, halfHeight, halfWidth, halfHeight));

    var cam3 = @PerspectiveCamera(width, height, @vec3(5f, 0f, 0f), @vec3(-1f, 0f, 0f), @vec3(0f, 1f, 0f));
    cam3:viewport(@vec4i(halfWidth, 0, halfWidth, halfHeight));

    var cam4 = @PerspectiveCamera(width, height, @vec3(-5f, 0f, 0f), @vec3(1f, 0f, 0f), @vec3(0f, 1f, 0f));
    cam4:viewport(@vec4i(halfWidth, halfHeight, halfWidth, halfHeight));
}